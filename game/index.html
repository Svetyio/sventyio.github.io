<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Royale (Local)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #f0e6d2; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        #game-container {
            background: url('https://i.imgur.com/MJEcHwQ.png'); /* –ü—Ä–∏–º–µ—Ä–Ω–∞ –∞—Ä–µ–Ω–∞ */
            background-size: cover;
            border: 5px solid #8b4513;
            position: relative;
            overflow: hidden;
        }
        /* –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞ –º–æ–±–∏–ª–µ–Ω –∏–∑–≥–ª–µ–¥ */
        @media (orientation: portrait) {
            #game-container {
                width: 90vw;
                height: calc(90vw * 1.777); /* –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ —Å—ä–æ—Ç–Ω–æ—à–µ–Ω–∏–µ 16:9 */
            }
        }
        @media (orientation: landscape) {
            #game-container {
                width: 90vh;
                height: calc(90vh * 0.5625); /* –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ —Å—ä–æ—Ç–Ω–æ—à–µ–Ω–∏–µ 16:9 */
            }
        }
        .tower {
            width: 50px;
            height: 100px;
            background-color: #d2b48c;
            border: 2px solid #8b4513;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .tower-king-player { bottom: 10%; left: 50%; transform: translateX(-50%); height: 120px; }
        .tower-princess-player-left { bottom: 30%; left: 15%; }
        .tower-princess-player-right { bottom: 30%; right: 15%; }
        .tower-king-opponent { top: 10%; left: 50%; transform: translateX(-50%); height: 120px; }
        .tower-princess-opponent-left { top: 30%; left: 15%; }
        .tower-princess-opponent-right { top: 30%; right: 15%; }
        .river {
            position: absolute;
            top: 45%;
            left: 0;
            width: 100%;
            height: 10%;
            background-color: #87ceeb;
        }
        .bridge-player {
            position: absolute;
            bottom: 20%;
            left: 40%;
            width: 20%;
            height: 5%;
            background-color: #b8860b;
        }
        .bridge-opponent {
            position: absolute;
            top: 20%;
            left: 40%;
            width: 20%;
            height: 5%;
            background-color: #b8860b;
        }
        .card {
            width: 80px;
            height: 100px;
            background-color: #fff;
            border: 1px solid #000;
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .card-name { font-weight: bold; margin-bottom: 5px; }
        .card-stats { font-size: 0.8em; }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="tower tower-king-player" id="player-king-tower" data-health="3500">üëë 3500</div>
        <div class="tower tower-princess-player-left" id="player-princess-tower-left" data-health="2500">üë∏ 2500</div>
        <div class="tower tower-princess-player-right" id="player-princess-tower-right" data-health="2500">üë∏ 2500</div>

        <div class="tower tower-king-opponent" id="opponent-king-tower" data-health="3500">üëë 3500</div>
        <div class="tower tower-princess-opponent-left" id="opponent-princess-tower-left" data-health="2500">üë∏ 2500</div>
        <div class="tower tower-princess-opponent-right" id="opponent-princess-tower-right" data-health="2500">üë∏ 2500</div>

        <div class="river"></div>

        <div class="bridge-player"></div>
        <div class="bridge-opponent"></div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const playerKingTower = document.getElementById('player-king-tower');
        const playerPrincessTowerLeft = document.getElementById('player-princess-tower-left');
        const playerPrincessTowerRight = document.getElementById('player-princess-tower-right');
        const opponentKingTower = document.getElementById('opponent-king-tower');
        const opponentPrincessTowerLeft = document.getElementById('opponent-princess-tower-left');
        const opponentPrincessTowerRight = document.getElementById('opponent-princess-tower-right');

        // –î–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–µ –Ω–∞ –∫–∞—Ä—Ç–∏ —Å —Ä–µ–∞–ª–Ω–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–ø—Ä–∏–º–µ—Ä–Ω–∏)
        const cardsData = [
            { name: 'Knight', elixir: 3, health: 1450, damage: 159, speed: 'medium', target: 'ground', type: 'troop' },
            { name: 'Archers', elixir: 3, health: 310, damage: 67, speed: 'fast', target: 'air+ground', type: 'troop' },
            { name: 'Giant', elixir: 5, health: 5200, damage: 126, speed: 'medium', target: 'buildings', type: 'troop' },
            { name: 'Goblin', elixir: 2, health: 216, damage: 79, speed: 'very fast', target: 'ground', type: 'troop' },
            { name: 'Spear Goblins', elixir: 2, health: 190, damage: 52, speed: 'very fast', target: 'air+ground', type: 'troop' },
            { name: 'Mini P.E.K.K.A', elixir: 4, health: 1050, damage: 580, speed: 'medium', target: 'ground', type: 'troop' },
            { name: 'Musketeer', elixir: 4, health: 598, damage: 176, speed: 'medium', target: 'air+ground', type: 'troop' },
            { name: 'Hog Rider', elixir: 4, health: 1400, damage: 160, speed: 'fast', target: 'buildings', type: 'troop' },
            { name: 'Valkyrie', elixir: 4, health: 1660, damage: 127, speed: 'medium', target: 'ground', type: 'troop', splash: true },
            { name: 'Wizard', elixir: 5, health: 660, damage: 240, speed: 'medium', target: 'air+ground', type: 'troop', splash: true },
            { name: 'Baby Dragon', elixir: 4, health: 1000, damage: 140, speed: 'fast', target: 'air+ground', type: 'troop', splash: true },
            { name: 'Skeleton Army', elixir: 3, health: 30 * 15, damage: 30 * 15, speed: 'fast', target: 'ground', type: 'troop', count: 15 }, // –ö–æ—Ä–∏–≥–∏—Ä–∞–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            { name: 'Arrows', elixir: 3, damage: 288, radius: 4, type: 'spell', target: 'area' },
            { name: 'Fireball', elixir: 4, damage: 651, radius: 2.5, type: 'spell', target: 'area' },
            { name: 'Rage', elixir: 2, duration: 6, type: 'spell', effect: 'speed+damage' },
            { name: 'Inferno Tower', elixir: 5, health: 1100, damageProgression: 'yes', speed: 'slow', target: 'buildings', type: 'building' }
        ];

        let playerDeck = [];
        let opponentDeck = [];

        function initializeDecks() {
            // –í–∑–µ–º–∞–º–µ 8 —Å–ª—É—á–∞–π–Ω–∏ –∫–∞—Ä—Ç–∏ –∑–∞ –∏–≥—Ä–∞—á–∞ –∏ –æ–ø–æ–Ω–µ–Ω—Ç–∞
            const allCards = [...cardsData];
            for (let i = 0; i < 8; i++) {
                let randomIndex = Math.floor(Math.random() * allCards.length);
                playerDeck.push({...allCards[randomIndex]});
                allCards.splice(randomIndex, 1);
            }
            for (let i = 0; i < 8; i++) {
                let randomIndex = Math.floor(Math.random() * allCards.length);
                opponentDeck.push({...allCards[randomIndex]});
                allCards.splice(randomIndex, 1);
            }
            console.log("Player Deck:", playerDeck);
            console.log("Opponent Deck:", opponentDeck);
        }

        let gameObjects = [];
        let elixirPlayer = 5;
        let elixirOpponent = 5;
        const maxElixir = 10;
        const elixirGainRate = 1; // –ï–ª–∏–∫—Å–∏—Ä —Å–µ –¥–æ–±–∞–≤—è –≤—Å—è–∫–∞ —Å–µ–∫—É–Ω–¥–∞ (–ø—Ä–∏–º–µ—Ä–Ω–æ)
        let lastElixirUpdate = Date.now();

        function updateElixir() {
            const now = Date.now();
            const timePassed = (now - lastElixirUpdate) / 1000; // –í —Å–µ–∫—É–Ω–¥–∏

            if (elixirPlayer < maxElixir) {
                elixirPlayer += elixirGainRate * timePassed;
                if (elixirPlayer > maxElixir) elixirPlayer = maxElixir;
            }
            if (elixirOpponent < maxElixir) {
                elixirOpponent += elixirGainRate * timePassed;
                if (elixirOpponent > maxElixir) elixirOpponent = maxElixir;
            }
            lastElixirUpdate = now;
            // –ú–æ–∂–µ –¥–∞ —Å–µ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–∞ –µ–ª–∏–∫—Å–∏—Ä–∞ —Ç—É–∫
        }

        function spawnCard(cardData, owner, position) {
            const cardElement = document.createElement('div');
            cardElement.classList.add('card');
            cardElement.innerHTML = `<div class="card-name">${cardData.name}</div><div class="card-stats">Elixir: ${cardData.elixir}<br>HP: ${cardData.health}<br>DMG: ${cardData.damage}</div>`;
            cardElement.style.left = `${position.x}px`;
            cardElement.style.top = `${position.y}px`;
            gameContainer.appendChild(cardElement);

            const gameObject = {
                element: cardElement,
                data: {...cardData},
                owner: owner,
                position: {...position},
                health: cardData.health || 0
            };
            gameObjects.push(gameObject);
            return gameObject;
        }

        function moveObject(gameObject, targetPosition, speed = 10) { // –ü–æ-–≤–∏—Å–æ–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç –∑–∞ –ø–æ-–ø–ª–∞–≤–Ω–æ –¥–≤–∏–∂–µ–Ω–∏–µ
            const dx = targetPosition.x - gameObject.position.x;
            const dy = targetPosition.y - gameObject.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > 1) {
                const stepX = dx / distance * speed;
                const stepY = dy / distance * speed;
                gameObject.position.x += stepX;
                gameObject.position.y += stepY;
                gameObject.element.style.left = `${gameObject.position.x}px`;
                gameObject.element.style.top = `${gameObject.position.y}px`;
                return false; // –í—Å–µ –æ—â–µ —Å–µ –¥–≤–∏–∂–∏
            } else {
                gameObject.position.x = targetPosition.x;
                gameObject.position.y = targetPosition.y;
                gameObject.element.style.left = `${gameObject.position.x}px`;
                gameObject.element.style.top = `${gameObject.position.y}px`;
                return true; // –î–æ—Å—Ç–∏–≥–Ω–∞ —Ü–µ–ª—Ç–∞
            }
        }

        function isOverRiver(position) {
            const gameRect = gameContainer.getBoundingClientRect();
            const riverTop = gameRect.height * 0.45;
            const riverBottom = gameRect.height * 0.55;
            return position.y > riverTop && position.y < riverBottom;
        }

        function isOverPlayerBridge(position) {
            const gameRect = gameContainer.getBoundingClientRect();
            const bridgeTop = gameRect.height * 0.8;
            const bridgeBottom = gameRect.height * 0.85;
            const bridgeLeft = gameRect.width * 0.4;
            const bridgeRight = gameRect.width * 0.6;
            return position.y > bridgeTop && position.y < bridgeBottom && position.x > bridgeLeft && position.x < bridgeRight;
        }

        function isOverOpponentBridge(position) {
            const gameRect = gameContainer.getBoundingClientRect();
            const bridgeTop = gameRect.height * 0.2;
            const bridgeBottom = gameRect.height * 0.25;
            const bridgeLeft = gameRect.width * 0.4;
            const bridgeRight = gameRect.width * 0.6;
            return position.y > bridgeTop && position.y < bridgeBottom && position.x > bridgeLeft && position.x < bridgeRight;
        }

        function getClosestTarget(unit, targets) {
            let closest = null;
            let minDistance = Infinity;
            for (const target of targets) {
                const dx = target.position.x - unit.position.x;
                const dy = target.position.y - unit.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = target;
                }
            }
            return closest;
        }

        function applyDamage(target, damage) {
            target.health -= damage;
            if (target.element) {
                // –ú–æ–∂–µ –¥–∞ —Å–µ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä–∞ –ø—Ä–æ–º—è–Ω–∞—Ç–∞ –≤ –∑–¥—Ä–∞–≤–µ—Ç–æ
                if (target.element.dataset && target.element.dataset.health) {
                    target.element.dataset.health = target.health;
                    target.element.textContent = target.element.textContent.split(' ')[0] + ' ' + Math.max(0, target.health);
                } else if (target.element.id.includes('tower')) {
                    target.element.textContent = target.element.textContent.split(' ')[0] + ' ' + Math.max(0, target.health);
                    target.element.dataset.health = target.health;
                }
            }
            if (target.health <= 0) {
                // –û–±–µ–∫—Ç—ä—Ç –µ —É–Ω–∏—â–æ–∂–µ–Ω
                if (target.element) {
                    target.element.remove();
                }
                gameObjects = gameObjects.filter(obj => obj !== target);
                console.log(`${target.data.name || target.element.id} destroyed!`);
                checkWinCondition();
            }
        }

        function getTowers(owner) {
            if (owner === 'player') {
                return [
                    { element: playerKingTower, health: parseInt(playerKingTower.dataset.health), position: { x: gameContainer.offsetWidth / 2, y: gameContainer.offsetHeight * 0.15 }, isTower: true },
                    { element: playerPrincessTowerLeft, health: parseInt(playerPrincessTowerLeft.dataset.health), position: { x: gameContainer.offsetWidth * 0.15, y: gameContainer.offsetHeight * 0.35 }, isTower: true },
                    { element: playerPrincessTowerRight, health: parseInt(playerPrincessTowerRight.dataset.health), position: { x: gameContainer.offsetWidth * 0.85, y: gameContainer.offsetHeight * 0.35 }, isTower: true }
                ].filter(tower => tower.health > 0);
            } else {
                return [
                    { element: opponentKingTower, health: parseInt(opponentKingTower.dataset.health), position: { x: gameContainer.offsetWidth / 2, y: gameContainer.offsetHeight * 0.

–ï—Ç–æ –≤—Ç–æ—Ä–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç –∫–æ–¥–∞, –∫–æ—è—Ç–æ –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞ JavaScript –ª–æ–≥–∏–∫–∞—Ç–∞:
            offsetHeight * 0.85 }, isTower: true },
                    { element: opponentPrincessTowerLeft, health: parseInt(opponentPrincessTowerLeft.dataset.health), position: { x: gameContainer.offsetWidth * 0.15, y: gameContainer.offsetHeight * 0.65 }, isTower: true },
                    { element: opponentPrincessTowerRight, health: parseInt(opponentPrincessTowerRight.dataset.health), position: { x: gameContainer.offsetWidth * 0.85, y: gameContainer.offsetHeight * 0.65 }, isTower: true }
                ].filter(tower => tower.health > 0);
            }
        }

        function handleCombat() {
            for (const unit of gameObjects) {
                if (unit.data.type === 'troop') {
                    let target = null;
                    if (unit.owner === 'player') {
                        const opponentTowers = getTowers('opponent');
                        const opponentUnits = gameObjects.filter(obj => obj.owner === 'opponent' && obj.data.type === 'troop');

                        if (unit.data.target === 'buildings') {
                            target = getClosestTarget(unit, opponentTowers);
                        } else if (opponentUnits.length > 0) {
                            target = getClosestTarget(unit, opponentUnits);
                        } else {
                            target = getClosestTarget(unit, opponentTowers);
                        }
                    } else {
                        const playerTowers = getTowers('player');
                        const playerUnits = gameObjects.filter(obj => obj.owner === 'player' && obj.data.type === 'troop');

                        if (unit.data.target === 'buildings') {
                            target = getClosestTarget(unit, playerTowers);
                        } else if (playerUnits.length > 0) {
                            target = getClosestTarget(unit, playerUnits);
                        } else {
                            target = getClosestTarget(unit, playerTowers);
                        }
                    }

                    if (target) {
                        const dx = target.position.x - unit.position.x;
                        const dy = target.position.y - unit.position.y;
                        const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
                        const attackRange = 50; // –ü—Ä–∏–º–µ—Ä–Ω–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –∑–∞ –∞—Ç–∞–∫–∞

                        if (distanceToTarget < attackRange) {
                            // –ê—Ç–∞–∫—É–≤–∞ —Ü–µ–ª—Ç–∞
                            if (unit.attackCooldown === undefined || unit.attackCooldown <= 0) {
                                applyDamage(target, unit.data.damage);
                                unit.attackCooldown = 60 / (unit.data.speed === 'fast' ? 1.5 : unit.data.speed === 'very fast' ? 1 : 2); // –ü—Ä–∏–º–µ—Ä–Ω–∞ —Å–∫–æ—Ä–æ—Å—Ç –Ω–∞ –∞—Ç–∞–∫–∞
                            } else if (unit.attackCooldown > 0) {
                                unit.attackCooldown--;
                            }
                        } else {
                            // –î–≤–∏–∂–∏ —Å–µ –∫—ä–º —Ü–µ–ª—Ç–∞
                            let targetPos = {...target.position};
                            if (target.isTower) {
                                const rect = target.element.getBoundingClientRect();
                                targetPos = { x: rect.left + rect.width / 2 - (unit.element ? unit.element.offsetWidth / 2 : 0), y: rect.top + rect.height / 2 - (unit.element ? unit.element.offsetHeight / 2 : 0) };
                            }
                            moveObject(unit, targetPos, unit.data.speed === 'fast' ? 2 : unit.data.speed === 'very fast' ? 3 : 1);
                        }
                    } else {
                        // –ù—è–º–∞ —Ü–µ–ª - –º–æ–∂–µ –¥–∞ —Å–µ –¥–≤–∏–∂–∏ –∫—ä–º –≤—Ä–∞–∂–µ—Å–∫–∞—Ç–∞ —Å—Ç—Ä–∞–Ω–∞ –ø–æ –ø—ä—Ç—è
                        let targetY = unit.owner === 'player' ? gameContainer.offsetHeight * 0.1 : gameContainer.offsetHeight * 0.9;
                        let bridgeX = gameContainer.offsetWidth / 2 - (unit.element ? unit.element.offsetWidth / 2 : 0);
                        let moveTarget = { x: bridgeX, y: targetY };

                        if (unit.data.target === 'ground' && isOverRiver(unit.position) && !isOverPlayerBridge(unit.position) && !isOverOpponentBridge(unit.position)) {
                            moveTarget.x = gameContainer.offsetWidth / 2 - (unit.element ? unit.element.offsetWidth / 2 : 0);
                            moveTarget.y = unit.owner === 'player' ? gameContainer.offsetHeight * 0.825 : gameContainer.offsetHeight * 0.225; // –ö—ä–º –º–æ—Å—Ç–∞
                        }
                        moveObject(unit, moveTarget, unit.data.speed === 'fast' ? 2 : unit.data.speed === 'very fast' ? 3 : 1);
                    }
                }
            }
        }

        function checkWinCondition() {
            const playerTowersAlive = getTowers('player').length;
            const opponentTowersAlive = getTowers('opponent').length;

            if (playerTowersAlive === 0) {
                console.log("Opponent Wins!");
                stopGameLoop();
            } else if (opponentTowersAlive === 0) {
                console.log("Player Wins!");
                stopGameLoop();
            }
        }

        function gameLoop() {
            updateElixir();
            handleCombat();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            initializeDecks();
            // –ü—Ä–∏–º–µ—Ä–Ω–æ —Å–ø–∞—É–Ω–≤–∞–Ω–µ –Ω–∞ –∫–∞—Ä—Ç–∞ –æ—Ç –∏–≥—Ä–∞—á–∞
            const playerSpawnPosition = { x: gameContainer.offsetWidth * 0.2, y: gameContainer.offsetHeight * 0.8 };
            const randomPlayerCard = playerDeck[Math.floor(Math.random() * playerDeck.length)];
            if (elixirPlayer >= randomPlayerCard.elixir) {
                spawnCard(randomPlayerCard, 'player', playerSpawnPosition);
                elixirPlayer -= randomPlayerCard.elixir;
            }

            // –ü—Ä–∏–º–µ—Ä–Ω–æ AI —Å–ø–∞—É–Ω–≤–∞–Ω–µ –Ω–∞ –∫–∞—Ä—Ç–∞
            setTimeout(() => {
                const opponentSpawnPosition = { x: gameContainer.offsetWidth * 0.8, y: gameContainer.offsetHeight * 0.2 };
                const randomOpponentCard = opponentDeck[Math.floor(Math.random() * opponentDeck.length)];
                if (elixirOpponent >= randomOpponentCard.elixir) {
                    spawnCard(randomOpponentCard, 'opponent', opponentSpawnPosition);
                    elixirOpponent -= randomOpponentCard.elixir;
                }
            }, 2000);

            gameLoop();
        }

        function stopGameLoop() {
            cancelAnimationFrame(gameLoop);
        }

        // –°—Ç–∞—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –∏–≥—Ä–∞—Ç–∞ —Å–ª–µ–¥ –∑–∞—Ä–µ–∂–¥–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞—Ç–∞
        window.onload = startGame;

        // –î–æ–±–∞–≤—è–Ω–µ –Ω–∞ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç –∑–∞ "–ø—É—Å–∫–∞–Ω–µ" –Ω–∞ –∫–∞—Ä—Ç–∞ –ø—Ä–∏ –∫–ª–∏–∫–≤–∞–Ω–µ (–∑–∞ —Ç–µ—Å—Ç–≤–∞–Ω–µ)
        gameContainer.addEventListener('click', (event) => {
            const rect = gameContainer.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const randomPlayerCard = playerDeck[Math.floor(Math.random() * playerDeck.length)];
            if (elixirPlayer >= randomPlayerCard.elixir) {
                spawnCard(randomPlayerCard, 'player', { x: x - 40, y: y - 50 }); // –¶–µ–Ω—Ç—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –∫–∞—Ä—Ç–∞—Ç–∞ –æ–∫–æ–ª–æ –∫–ª–∏–∫–∞
                elixirPlayer -= randomPlayerCard.elixir;
                console.log(`Player spawned ${randomPlayerCard.name}, Elixir: ${elixirPlayer.toFixed(2)}`);
            } else {
                console.log("Not enough elixir!");
            }
        });

        // AI –ª–æ–≥–∏–∫–∞ (–º–Ω–æ–≥–æ –±–∞–∑–æ–≤–∞)
        setInterval(() => {
            if (getTowers('opponent').length > 0) {
                const availableOpponentCards = opponentDeck.filter(card => elixirOpponent >= card.elixir);
                if (availableOpponentCards.length > 0) {
                    const randomCard = availableOpponentCards[Math.floor(Math.random() * availableOpponentCards.length)];
                    const spawnX = gameContainer.offsetWidth * (0.3 + Math.random() * 0.4);
                    const spawnY = gameContainer.offsetHeight * 0.2;
                    spawnCard(randomCard, 'opponent', { x: spawnX, y: spawnY });
                    elixirOpponent -= randomCard.elixir;
                    console.log(`Opponent spawned ${randomCard.name}, Elixir: ${elixirOpponent.toFixed(2)}`);
                }
            }
        }, 3000); // AI –ø—É—Å–∫–∞ –∫–∞—Ä—Ç–∞ –Ω–∞ –≤—Å–µ–∫–∏ 3 —Å–µ–∫—É–Ω–¥–∏ (–ø—Ä–∏–º–µ—Ä–Ω–æ)

    </script>
</body>
</html>
