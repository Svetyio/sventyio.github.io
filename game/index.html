<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8" />
    <title>Svetlyo Slot Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom,#232526,#414345 100%);
            min-height: 100vh;
        }
        body {
            color: #fff;
            font-family: 'Segoe UI', Arial, sans-serif;
            text-align: center;
            user-select: none;
        }
        .small-title {
            font-size: 28px;
            font-weight: 700;
            margin: 28px auto 0 auto;
            letter-spacing: 2px;
            max-width: 99vw;
            text-shadow: 0 2px 14px #000, 0 0 4px #F2C811;
        }
        #container {
            position: relative;
            width: 100vw;
            max-width: 440px;
            margin: 0 auto;
            height: 420px;
        }
        #gameCanvas {
            display: block;
            margin: 32px auto 12px auto;
            background: #17181C;
            border: 8px solid #FFD700;
            border-radius: 24px;
            box-shadow: 0 0 28px #FFD70044,0 0 12px #000;
            max-width: 98vw;
            width: 98vw;
            height: 98vw;
            min-width: 240px;
            min-height: 240px;
            max-height: 420px;
            touch-action: none;
            position: relative;
        }
        #info-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 14px;
            margin: 20px auto 10px auto;
            width: 100%;
            max-width: 600px;
            flex-wrap: wrap;
        }
        .info-box {
            background: #232526;
            border: 2px solid #888;
            border-radius: 13px;
            box-shadow: 0 0 10px #23252644;
            font-size: 18px;
            min-width: 90px;
            min-height: 38px;
            padding: 8px 18px;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            transition: color 0.5s, background 0.5s;
        }
        #coins { background-color: #2ecc71; }
        #lastWin { background-color: #e74c3c; }
        #totalWin { background-color: #2980b9; }
        #bets {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin: 18px auto 0 auto;
            width: 100%;
            max-width: 600px;
            flex-wrap: wrap;
            pointer-events: none;
        }
        .btn {
            padding: 10px 22px;
            font-size: 18px;
            color: #fff;
            background-color: #232526;
            border: none;
            border-radius: 13px;
            cursor: pointer;
            margin: 0;
            min-width: 54px;
            min-height: 38px;
            outline: none;
            box-shadow: 0 1px 4px #0006;
            font-weight: 600;
            letter-spacing: 1px;
            transition: background 0.2s, color 0.2s, transform 0.15s, box-shadow 0.2s;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-drag: none;
        }
        .btn.selected-bet,
        .btn:active.selected-bet {
            background-color: #00cc00 !important;
            color: #fff !important;
            box-shadow: 0 0 10px 2px #00cc00;
            font-weight: bold;
        }
        .btn:focus-visible:not(.selected-bet) {
            background-color: #444;
            color: #fff;
        }
        #spinBtn, #restartBtn {
            position: relative;
            z-index: 10;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-user-drag: none;
            pointer-events: auto;
        }
        #spinBtn {
            background: linear-gradient(145deg,#e74c3c,#e67e22 80%);
            border-radius: 50%;
            width: 110px;
            height: 110px;
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            margin: 28px auto 12px auto;
            display: block;
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0 0 26px #e67e22,0 0 48px #fff0;
            border: none;
            outline: none;
            animation: pulseSpinBtn 1.3s infinite alternate;
        }
        @keyframes pulseSpinBtn {
            0% { box-shadow: 0 0 24px #e67e22,0 0 10px #fff0; }
            100% { box-shadow: 0 0 44px #FFD700,0 0 44px #fff4; transform: scale(1.08);}
        }
        #spinBtn:hover, #spinBtn:focus-visible {
            background: linear-gradient(145deg,#e67e22,#FFD700 80%);
            transform: scale(1.12);
        }
        #spinBtn.auto {
            background: linear-gradient(145deg,#00cc00,#26df26 80%)!important;
            box-shadow: 0 0 28px #00cc00,0 0 48px #fff;
            animation: none !important;
            transform: scale(1.10);
        }
        #restartBtn {
            background: #1e90ff;
            border-radius: 50%;
            width: 88px;
            height: 88px;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            margin: 18px auto 12px auto;
            display: block;
            transition: background 0.3s, transform 0.2s;
            box-shadow: 0 0 14px #1e90ff99;
            border: none;
            outline: none;
        }
        #restartBtn:hover, #restartBtn:focus-visible {
            background: #00ccff;
            transform: scale(1.05);
        }
        #winLabel {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 18px;
            font-size: 32px;
            font-weight: 900;
            color: #FFD700;
            text-shadow: 0 0 12px #FFD700, 0 2px 17px #fff;
            background: rgba(40,40,0,0.44);
            padding: 10px 32px;
            border-radius: 30px;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.4s;
            white-space: nowrap;
        }
        #winLabel.active {
            opacity: 1 !important;
            pointer-events: auto;
            transition: none;
        }
        button, .btn {
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            pointer-events: auto !important;
            position: relative;
        }
        button:active, .btn:active { transform: scale(1.01);}
        button[draggable], .btn[draggable] { draggable: false !important;}
        button, .btn { touch-action: manipulation; }
        @media (max-width: 600px) {
            #winLabel { font-size: 18px; padding: 6px 12px; }
            #spinBtn, #restartBtn { width: 68px; height: 68px; font-size: 15px; }
            #bets { gap: 5px; }
            .btn { font-size: 13px; min-height: 24px; padding: 6px 10px; }
            .info-box { font-size: 12px; min-width: 38px; min-height: 13px; padding: 3px 7px; }
            .small-title { font-size: 15px; }
            #container {max-width:98vw; height:240px;}
        }
    </style>
</head>
<body>
    <div class="small-title">–î–æ–±—Ä–µ –¥–æ—à–ª–∏ –≤ Svetlyo Games</div>
    <div id="container">
        <span id="winLabel"></span>
        <canvas id="gameCanvas">
            –í–∞—à–∏—è—Ç –±—Ä–∞—É–∑—ä—Ä –Ω–µ –ø–æ–¥–¥—ä—Ä–∂–∞ canvas –∏–ª–∏ JavaScript –µ –∏–∑–∫–ª—é—á–µ–Ω.<br>
            –ú–æ–ª—è, –∞–∫—Ç–∏–≤–∏—Ä–∞–π—Ç–µ JavaScript –∏–ª–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –º–æ–¥–µ—Ä–µ–Ω –±—Ä–∞—É–∑—ä—Ä, –∑–∞ –¥–∞ –∏–≥—Ä–∞–µ—Ç–µ.
        </canvas>
    </div>
    <div id="info-row">
        <div class="info-box" id="coins">–ú–æ–Ω–µ—Ç–∏: 500</div>
        <div class="info-box" id="lastWin">–ü–æ—Å–ª–µ–¥–Ω–∞ –ø–µ—á–∞–ª–±–∞: 0</div>
        <div class="info-box" id="totalWin">–û–±—â–∞ –ø–µ—á–∞–ª–±–∞: 0</div>
    </div>
    <div id="bets">
        <button class="btn" onclick="setBet(20)" tabindex="1">20</button>
        <button class="btn" onclick="setBet(40)" tabindex="2">40</button>
        <button class="btn" onclick="setBet(60)" tabindex="3">60</button>
        <button class="btn" onclick="setBet(100)" tabindex="4">100</button>
        <button class="btn" onclick="setBet(200)" tabindex="5">200</–ò–ù</button>
    <button id="restartBtn" style="display:none" tabindex="7">–ù–æ–≤–∞ –∏–≥—Ä–∞</button>
    <script>
        // --- –û—Å–Ω–æ–≤–Ω–∏ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏ –∏ —Å—ä—Å—Ç–æ—è–Ω–∏–µ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const restartBtn = document.getElementById('restartBtn');
        const winLabel = document.getElementById('winLabel');
        const VALID_BETS = [20, 40, 60, 100, 200];

        const FRUITS = [
            {char:'üçé',name:'apple', points: 20, color: "#ff4040"},
            {char:'üçí',name:'cherry',points: 30, color: "#ff5bcd"},
            {char:'üçá',name:'grape', points: 40, color: "#a87fff"},
            {char:'üçÄ',name:'clover',points: 50, color: "#00e676"},
            {char:'üçâ',name:'watermelon',points: 60, color: "#42e1fe"}
        ];
        const FRUIT_CHARS = FRUITS.map(f=>f.char);
        const FRUIT_POINTS = {};
        FRUITS.forEach(f=>FRUIT_POINTS[f.char]=f.points);

        const GRID_SIZE = 5;

        let selectedBet = 20, coins = 500, lastWin = 0, totalWin = 0, grid = [];
        let spinning = false, autoSpin = false, autoSpinTimer = null, spinHoldTimeout = null;
        let animating = false, animationType = "", animationProgress = 0, animationGrid = [], animFrameId = null;
        let pointerDownTime = 0, pointerIsDown = false;
        let winLines = [], winFruits = [], winEffectActive = false, winEffectTimer = null;

        // --- –õ–æ–∫–∞–ª–Ω–æ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å–∞ ---
        function saveProgress() {
            const data = {
                coins,
                lastWin,
                totalWin,
                selectedBet
            };
            localStorage.setItem("svetlyo_slot_progress", JSON.stringify(data));
        }
        function loadProgress() {
            const data = localStorage.getItem("svetlyo_slot_progress");
            if (data) {
                try {
                    const obj = JSON.parse(data);
                    if (typeof obj.coins === 'number') coins = obj.coins;
                    if (typeof obj.lastWin === 'number') lastWin = obj.lastWin;
                    if (typeof obj.totalWin === 'number') totalWin = obj.totalWin;
                    if (VALID_BETS.includes(obj.selectedBet)) selectedBet = obj.selectedBet;
                } catch (e) {}
            }
        }

        function resizeCanvas() {
            let s = Math.min(window.innerWidth * 0.98, 420, window.innerHeight * 0.69);
            s = Math.max(s, 240);
            canvas.width = s;
            canvas.height = s;
            drawGrid();
        }
        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("load", () => { loadProgress(); resizeCanvas(); drawGrid(); });

        window.setBet = function(bet) {
            bet = Number(bet);
            if (!VALID_BETS.includes(bet)) return;
            selectedBet = bet;
            document.querySelectorAll('#bets .btn').forEach(btn => {
                let val = Number(btn.innerText);
                if (VALID_BETS.includes(val) && val === bet) btn.classList.add('selected-bet');
                else btn.classList.remove('selected-bet');
            });
            saveProgress();
        };

        function randomFruit() {
            let chance = Math.random();
            if (chance < 0.28) return FRUITS[0].char;
            if (chance < 0.53) return FRUITS[1].char;
            if (chance < 0.73) return FRUITS[2].char;
            if (chance < 0.89) return FRUITS[3].char;
            return FRUITS[4].char;
        }
        function generateGrid() {
            let arr = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                let row = [];
                for (let c = 0; c < GRID_SIZE; c++) row.push(randomFruit());
                arr.push(row);
            }
            // 40% —à–∞–Ω—Å –∑–∞ —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–∞ –ª–∏–Ω–∏—è
            if (Math.random() < 0.40) {
                let winRow = Math.floor(Math.random() * GRID_SIZE);
                let winFruit = FRUIT_CHARS[Math.floor(Math.random() * FRUIT_CHARS.length)];
                for (let c = 0; c < GRID_SIZE; c++) arr[winRow][c] = winFruit;
            }
            // 25% —à–∞–Ω—Å –∑–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª–Ω–∞ –ª–∏–Ω–∏—è
            if (Math.random() < 0.25) {
                let winCol = Math.floor(Math.random() * GRID_SIZE);
                let winFruit = FRUIT_CHARS[Math.floor(Math.random() * FRUIT_CHARS.length)];
                for (let r = 0; r < GRID_SIZE; r++) arr[r][winCol] = winFruit;
            }
            // 15% —à–∞–Ω—Å –∑–∞ –¥–∏–∞–≥–æ–Ω–∞–ª
            if (Math.random() < 0.15) {
                let winFruit = FRUIT_CHARS[Math.floor(Math.random() * FRUIT_CHARS.length)];
                for (let i = 0; i < GRID_SIZE; i++) arr[i][i] = winFruit;
            }
            if (Math.random() < 0.12) {
                let winFruit = FRUIT_CHARS[Math.floor(Math.random() * FRUIT_CHARS.length)];
                for (let i = 0; i < GRID_SIZE; i++) arr[i][GRID_SIZE - 1 - i] = winFruit;
            }
            return arr;
        }

        function drawGrid(anim) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const c = canvas.width / (GRID_SIZE + .14), m = c * .125;
            const o = (canvas.width - (GRID_SIZE * c + (GRID_SIZE - 1) * m)) / 2;
            const y = (canvas.height - (GRID_SIZE * c + (GRID_SIZE - 1) * m)) / 2;
            for (let r = 0; r < GRID_SIZE; r++) for (let col = 0; col < GRID_SIZE; col++) {
                const x = o + col * (c + m), y0 = y + r * (c + m);
                ctx.save();
                ctx.fillStyle = '#141418';
                ctx.globalAlpha = .98;
                ctx.fillRect(x, y0, c, c);
                ctx.restore();

                ctx.save();
                ctx.font = `${Math.floor(c * .49)}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let fruit = grid[r][col];
                let highlight = false, animWinType = null;
                if (winEffectActive && winLines.length) {
                    for (let i = 0; i < winLines.length; i++) {
                        let line = winLines[i];
                        for (let j = 0; j < line.coords.length; j++) {
                            if (line.coords[j][0] === r && line.coords[j][1] === col) {
                                highlight = true;
                                animWinType = line.fruit;
                            }
                        }
                    }
                }

                if (anim && animating && animationGrid.length) {
                    let p = animationProgress;
                    if (animationType === "shake") {
                        let shake = Math.sin(p * 16 * Math.PI) * (1 - p) * 11;
                        let shakeAngle = Math.sin(p * 16 * Math.PI) * (1 - p) * 0.17;
                        ctx.translate(x + c / 2 + shake, y0 + c / 2);
                        ctx.rotate(shakeAngle);
                        ctx.shadowBlur = 17 * (1 - p);
                        ctx.shadowColor = "#fff";
                        ctx.globalAlpha = 0.8 + 0.2 * Math.cos(p * 8);
                        ctx.fillText(grid[r][col], 0, 0);
                    } else if (animationType === "spin") {
                        let oldF = animationGrid[r][col], newF = grid[r][col];
                        let blur = Math.round(13 * (1 - p));
                        let scaleOld = 1 - 0.8 * p, scaleNew = 0.7 + 0.3 * p;
                        let alphaOld = 1 - p * 1.2;
                        if (alphaOld < 0) alphaOld = 0;
                        let alphaNew = (p - 0.09) / 0.91;
                        if (alphaNew < 0) alphaNew = 0;
                        if (alphaNew > 1) alphaNew = 1;
                        let rotOld = -Math.PI * p * 1.1, rotNew = (1 - p) * Math.PI * 1.18;
                        ctx.save();
                        ctx.globalAlpha = alphaOld;
                        ctx.filter = `blur(${blur}px)`;
                        ctx.translate(x + c / 2, y0 + c / 2 - c * p * 0.9);
                        ctx.rotate(rotOld);
                        ctx.scale(scaleOld, scaleOld);
                        ctx.fillText(oldF, 0, 0);
                        ctx.restore();
                        ctx.save();
                        ctx.globalAlpha = alphaNew;
                        ctx.filter = `blur(${Math.round(17 * (1 - alphaNew))}px)`;
                        ctx.translate(x + c / 2, y0 + c / 2 + c * (1 - p) * 0.7);
                        ctx.rotate(rotNew);
                        ctx.scale(scaleNew, scaleNew);
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 22 * alphaNew;
                        ctx.fillText(newF, 0, 0);
                        ctx.restore();
                    }
                    ctx.restore();
                } else if (highlight) {
                    let fruitObj = FRUITS.find(f => f.char === fruit);
                    let t = Date.now() / 600;
                    ctx.save();
                    ctx.translate(x + c / 2, y0 + c / 2);
                    switch (fruitObj.name) {
                        case "apple":
                            ctx.scale(1.14 + 0.09 * Math.sin(t * 6), 1.14 + 0.09 * Math.cos(t * 4));
                            ctx.shadowColor = "#ff4040";
                            ctx.shadowBlur = 38 + 12 * Math.abs(Math.sin(t * 2));
                            break;
                        case "cherry":
                            ctx.translate(0, Math.sin(t * 7) * 16);
                            ctx.rotate(Math.sin(t * 4) * 0.13);
                            ctx.shadowColor = "#ff5bcd";
                            ctx.shadowBlur = 25;
                            break;
                        case "grape":
                            ctx.rotate(Math.sin(t * 2.5) * 0.55);
                            ctx.shadowColor = "#a87fff";
                            ctx.shadowBlur = 30;
                            break;
                        case "clover":
                            ctx.rotate(t * 2);
                            ctx.shadowColor = "#00e676";
                            ctx.shadowBlur = 40 + 12 * Math.abs(Math.cos(t * 2));
                            ctx.scale(1.10 + 0.12 * Math.cos(t * 2), 1.10 + 0.13 * Math.sin(t * 4));
                            break;
                        case "watermelon":
                            ctx.translate(Math.sin(t * 6) * 9, Math.cos(t * 10) * 6);
                            ctx.shadowColor = "#42e1fe";
                            ctx.shadowBlur = 30;
                            break;
                    }
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = "#fff";
                    ctx.font = `${Math.floor(c * .54)}px serif`;
                    ctx.fillText(fruit, 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 10;
                    ctx.translate(x + c / 2, y0 + c / 2 + .5);
                    ctx.fillText(grid[r][col], 0, 0);
                    ctx.restore();
                }
            }
            updateInfo();
        }

        function updateInfo() {
            document.getElementById('coins').innerText = `–ú–æ–Ω–µ—Ç–∏: ${coins}`;
            document.getElementById('lastWin').innerText = `–ü–æ—Å–ª–µ–¥–Ω–∞ –ø–µ—á–∞–ª–±–∞: ${lastWin}`;
            document.getElementById('totalWin').innerText = `–û–±—â–∞ –ø–µ—á–∞–ª–±–∞: ${totalWin}`;
            spinBtn.style.display = coins > 0 ? 'block' : 'none';
            restartBtn.style.display = coins > 0 ? 'none' : 'block';
        }

        function animate(type, cb) {
            animating = true;
            animationType = type;
            animationGrid = JSON.parse(JSON.stringify(grid));
            let duration = type === "shake" ? 450 : 1150;
            animationProgress = 0;
            let start = null;
            function step(ts) {
                if (!start) start = ts;
                let el = ts - start;
                animationProgress = Math.min(el / duration, 1);
                drawGrid(true);
                if (animationProgress < 1) animFrameId = requestAnimationFrame(step);
                else { animating = false; animationGrid = []; cb && cb(); }
            }
            animFrameId = requestAnimationFrame(step);
        }

        function animateSpin(newGrid, cb) {
            animationGrid = JSON.parse(JSON.stringify(grid));
            animate("spin", cb);
            grid = newGrid;
        }

        function animateShake(cb) {
            animate("shake", cb);
        }

        function spin(isAuto) {
            if (spinning || coins < selectedBet) return;
            spinning = true;
            stopWinEffect();
            animateShake(() => {
                coins -= selectedBet;
                let newGrid = generateGrid();
                animateSpin(newGrid, () => {
                    let { win, lines, fruits } = calcWins();
                    lastWin = win;
                    totalWin += win;
                    if (win > 0) coins += win;
                    drawGrid();
                    if (win > 0 && lines.length) {
                        winLines = lines;
                        winFruits = fruits;
                        startWinEffect();
                        winLabel.textContent = `–ü–ï–ß–ê–õ–ë–ê +${win}`;
                        winLabel.classList.add("active");
                    }
                    setTimeout(() => winLabel.classList.remove("active"), 1700);
                    spinning = false;
                    saveProgress();
                    if (autoSpin && coins < selectedBet) stopAutoSpin();
                    if (autoSpin && !isAuto) doAutoSpin();
                });
            });
        }

        function startWinEffect() {
            winEffectActive = true;
            function winAnimLoop() {
                if (!winEffectActive) return;
                drawGrid();
                winEffectTimer = setTimeout(winAnimLoop, 60);
            }
            winAnimLoop();
        }
        function stopWinEffect() {
            winEffectActive = false;
            winLines = [];
            winFruits = [];
            if (winEffectTimer) clearTimeout(winEffectTimer);
        }

        function calcWins() {
            let win = 0, lines = [], fruits = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                let f = grid[r][0];
                if (grid[r].every(ff => ff === f)) {
                    let points = FRUIT_POINTS[f] * selectedBet / 20;
                    win += points;
                    lines.push({type: "row", coords: Array.from({length:GRID_SIZE},(_,i)=>[r,i]), fruit: f});
                    fruits.push(f);
                }
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                let f = grid[0][c];
                let all = true;
                for (let r = 0; r < GRID_SIZE; r++)
                    if (grid[r][c] !== f) all = false;
                if (all) {
                    let points = FRUIT_POINTS[f] * selectedBet / 20;
                    win += points;
                    lines.push({type: "col", coords: Array.from({length:GRID_SIZE},(_,i)=>[i,c]), fruit: f});
                    fruits.push(f);
                }
            }
            let f1 = grid[0][0], all1 = true;
            for (let i = 0; i < GRID_SIZE; i++) if (grid[i][i] !== f1) all1 = false;
            if (all1) {
                let points = FRUIT_POINTS[f1] * selectedBet / 20;
                win += points;
                lines.push({type: "diag", coords: Array.from({length:GRID_SIZE},(_,i)=>[i,i]), fruit: f1});
                fruits.push(f1);
            }
            let f2 = grid[0][GRID_SIZE-1], all2 = true;
            for (let i = 0; i < GRID_SIZE; i++) if (grid[i][GRID_SIZE-1-i] !== f2) all2 = false;
            if (all2) {
                let points = FRUIT_POINTS[f2] * selectedBet / 20;
                win += points;
                lines.push({type: "diag2", coords: Array.from({length:GRID_SIZE},(_,i)=>[i,GRID_SIZE-1-i]), fruit: f2});
                fruits.push(f2);
            }
            return { win: Math.round(win), lines, fruits };
        }

        function restartGame() {
            stopWinEffect();
            coins = 500;
            lastWin = 0;
            totalWin = 0;
            grid = generateGrid();
            saveProgress();
            drawGrid();
        }

        function startSpinHold(e) {
            if (spinHoldTimeout) clearTimeout(spinHoldTimeout);
            pointerIsDown = true;
            pointerDownTime = Date.now();
            spinHoldTimeout = setTimeout(() => {
                if (pointerIsDown && !autoSpin) {
                    autoSpin = true;
                    spinBtn.classList.add('auto');
                    doAutoSpin();
                }
            }, 1500);
        }
        function stopSpinHold(e) {
            pointerIsDown = false;
            if (spinHoldTimeout) { clearTimeout(spinHoldTimeout); spinHoldTimeout = null; }
        }
        function doAutoSpin() {
            if (!autoSpin) { spinBtn.classList.remove('auto'); return; }
            if (coins < selectedBet) { stopAutoSpin(); return; }
            if (!spinning) spin(true);
            let nextSpin = 3000 + Math.random() * 2000;
            autoSpinTimer = setTimeout(doAutoSpin, nextSpin);
        }
        function stopAutoSpin() {
            autoSpin = false;
            spinBtn.classList.remove('auto');
            if (autoSpinTimer) { clearTimeout(autoSpinTimer); autoSpinTimer = null; }
        }

        spinBtn.addEventListener('mousedown', startSpinHold);
        spinBtn.addEventListener('touchstart', startSpinHold);
        spinBtn.addEventListener('mouseup', function (e) {
            stopSpinHold();
            if (autoSpin) return stopAutoSpin();
            let held = Date.now() - pointerDownTime;
            if (held < 1500 && !spinning) spin();
        });
        spinBtn.addEventListener('mouseleave', stopSpinHold);
        spinBtn.addEventListener('touchend', function (e) {
            stopSpinHold();
            if (autoSpin) return stopAutoSpin();
            let held = Date.now() - pointerDownTime;
            if (held < 1500 && !spinning) spin();
        });
        spinBtn.addEventListener('click', function (e) {
            if (autoSpin) { stopAutoSpin(); }
            stopWinEffect();
        });

        restartBtn.addEventListener('click', restartGame);
        document.querySelectorAll('#bets .btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const val = Number(btn.innerText);
                window.setBet(val);
            });
        });

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        grid = generateGrid();
        loadProgress();
        window.setBet(selectedBet);
        resizeCanvas();
        drawGrid();
    </script>
</body>
</html>
