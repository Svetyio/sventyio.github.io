<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>Mini Royale</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #20232a; color: #fff; font-family: sans-serif; }
    #gameCanvas { background: #3e8e41; display: block; margin: 20px auto; border-radius: 20px;}
    #hand { text-align: center; margin-top: 10px; }
    .card-btn {
      padding: 10px 18px;
      margin: 0 5px;
      border-radius: 12px;
      border: 2px solid #222;
      background: #fff;
      color: #20232a;
      font-weight: bold;
      cursor: pointer;
      font-size: 18px;
    }
    #elixir { text-align:center; font-size: 22px; margin-top: 5px;}
    #winMsg { text-align:center; font-size:28px; color: gold; margin-top: 14px;}
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="700" height="400"></canvas>
  <div id="elixir"></div>
  <div id="hand"></div>
  <div id="winMsg"></div>
<script>
// --- Game constants
const CARD_TYPES = [
  { name: '–í–æ–∏–Ω', emoji: 'üó°Ô∏è', hp: 80, dmg: 25, speed: 1.5, elixir: 3, color: '#e74c3c' },
  { name: '–°—Ç—Ä–µ–ª–µ—Ü', emoji: 'üèπ', hp: 60, dmg: 15, speed: 2, elixir: 2, color: '#f1c40f' },
  { name: '–¢–∞–Ω–∫', emoji: 'üõ°Ô∏è', hp: 180, dmg: 15, speed: 1, elixir: 5, color: '#2980b9' },
  { name: '–ë—ä—Ä–∑–∞–∫', emoji: '‚ö°', hp: 40, dmg: 20, speed: 3, elixir: 1, color: '#2ecc71' }
];
const PLAYER_BASE = { x: 100, y: 350 }, ENEMY_BASE = { x: 600, y: 50 };
const BASE_HP = 300, TOWER_HP = 120;
const CANVAS_W = 700, CANVAS_H = 400;
const MAX_ELIXIR = 10, ELIXIR_REGEN = 0.025;
const UNIT_SIZE = 32;

let game, ctx, aiTimer = 0;

// --- Game state
function newGame() {
  return {
    player: {
      units: [],
      baseHp: BASE_HP,
      towerHp: [TOWER_HP,TOWER_HP],
      elixir: 5
    },
    enemy: {
      units: [],
      baseHp: BASE_HP,
      towerHp: [TOWER_HP,TOWER_HP],
      elixir: 5
    },
    units: [],
    time: 0,
    winner: null
  };
}

// --- Rendering
function drawGame(g) {
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  // Arena
  ctx.fillStyle = "#53a653";
  ctx.fillRect(60,80,580,240);
  ctx.strokeStyle="#fff";
  ctx.lineWidth=2;
  ctx.strokeRect(60,80,580,240);

  // Towers
  drawTower(160, 320, g.player.towerHp[0]);
  drawTower(540, 320, g.player.towerHp[1]);
  drawTower(160, 60, g.enemy.towerHp[0]);
  drawTower(540, 60, g.enemy.towerHp[1]);

  // Bases
  drawBase(PLAYER_BASE.x, PLAYER_BASE.y, g.player.baseHp, true);
  drawBase(ENEMY_BASE.x, ENEMY_BASE.y, g.enemy.baseHp, false);

  // Units
  for (let u of g.units) drawUnit(u);

  // HP bars
  drawHpBar(PLAYER_BASE.x, PLAYER_BASE.y+32, g.player.baseHp, BASE_HP);
  drawHpBar(ENEMY_BASE.x, ENEMY_BASE.y+32, g.enemy.baseHp, BASE_HP);
}

function drawBase(x,y,hp,isPlayer) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(x,y,28,0,2*Math.PI);
  ctx.fillStyle = isPlayer ? '#4444ff' : '#ff4444';
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#fff';
  ctx.stroke();
  ctx.restore();
}
function drawTower(x,y,hp) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(x-18,y-18,36,36);
  ctx.fillStyle = "#888";
  ctx.fill();
  ctx.lineWidth=2;
  ctx.strokeStyle="#fff";
  ctx.stroke();
  drawHpBar(x, y+20, hp, TOWER_HP);
  ctx.restore();
}
function drawUnit(u) {
  ctx.save();
  ctx.beginPath();
  ctx.arc(u.x, u.y, UNIT_SIZE/2, 0, 2*Math.PI);
  ctx.fillStyle = u.color;
  ctx.fill();
  ctx.font = "22px sans-serif";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillStyle="#fff";
  ctx.fillText(u.emoji, u.x, u.y);
  ctx.restore();
  drawHpBar(u.x, u.y+20, u.hp, u.maxHp);
}
function drawHpBar(x,y,hp,maxHp) {
  ctx.save();
  let pct = Math.max(0,hp)/maxHp;
  ctx.fillStyle = "#222";
  ctx.fillRect(x-18, y, 36, 5);
  ctx.fillStyle = pct>0.5 ? "#2ecc71" : pct>0.2?"#f1c40f":"#e74c3c";
  ctx.fillRect(x-18, y, 36*pct, 5);
  ctx.restore();
}

// --- Game logic
function gameTick(g, dt) {
  // Regen elixir
  g.player.elixir = Math.min(MAX_ELIXIR, g.player.elixir+ELIXIR_REGEN*dt);
  g.enemy.elixir = Math.min(MAX_ELIXIR, g.enemy.elixir+ELIXIR_REGEN*dt);

  // Units move
  for (let u of g.units) {
    if (u.hp<=0) continue;
    let target = u.isPlayer ? enemyTarget(g, u) : playerTarget(g, u);
    if (target && dist(u,target)<=u.range) {
      // Attack
      if (!u.lastAttack || g.time-u.lastAttack>40) {
        target.hp -= u.dmg;
        u.lastAttack = g.time;
      }
    } else if (target) {
      // Move towards
      let angle = Math.atan2(target.y-u.y, target.x-u.x);
      u.x += Math.cos(angle)*u.speed*dt*0.04;
      u.y += Math.sin(angle)*u.speed*dt*0.04;
    }
  }
  // Remove dead units
  g.units = g.units.filter(u=>u.hp>0);

  // Check win
  if (g.enemy.baseHp<=0) g.winner = '–í–ò–ï';
  if (g.player.baseHp<=0) g.winner = 'AI';
}

function dist(a,b) {
  let dx = a.x-b.x, dy = a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy);
}

function enemyTarget(g, u) {
  // 1. –ë–ª–∏–∑—ä–∫ –∏–≥—Ä–∞—á–∫–∏ —é–Ω–∏—Ç, 2. –∫—É–ª–∞, 3. –±–∞–∑–∞
  let candidates = g.player.units.filter(x=>dist(u,x)<80);
  if (candidates.length) return candidates[0];
  for (let i=0;i<2;i++) if (g.player.towerHp[i]>0 && dist(u, tPos(i,true))<60) return {hp:g.player.towerHp[i], setHp:v=>g.player.towerHp[i]=v, x:tPos(i,true).x, y:tPos(i,true).y};
  if (g.player.baseHp>0 && dist(u,PLAYER_BASE)<48) return {hp:g.player.baseHp, setHp:v=>g.player.baseHp=v, x:PLAYER_BASE.x, y:PLAYER_BASE.y};
  return null;
}
function playerTarget(g, u) {
  // 1. –ë–ª–∏–∑—ä–∫ –≤—Ä–∞–≥ —é–Ω–∏—Ç, 2. –∫—É–ª–∞, 3. –±–∞–∑–∞
  let candidates = g.enemy.units.filter(x=>dist(u,x)<80);
  if (candidates.length) return candidates[0];
  for (let i=0;i<2;i++) if (g.enemy.towerHp[i]>0 && dist(u, tPos(i,false))<60) return {hp:g.enemy.towerHp[i], setHp:v=>g.enemy.towerHp[i]=v, x:tPos(i,false).x, y:tPos(i,false).y};
  if (g.enemy.baseHp>0 && dist(u,ENEMY_BASE)<48) return {hp:g.enemy.baseHp, setHp:v=>g.enemy.baseHp=v, x:ENEMY_BASE.x, y:ENEMY_BASE.y};
  return null;
}
function tPos(idx, isPlayer) {
  return { x: idx==0?160:540, y: isPlayer?320:60 };
}

// --- Card UI
function renderHand() {
  let hand = document.getElementById('hand');
  hand.innerHTML = '';
  CARD_TYPES.forEach((c,i)=>{
    let btn = document.createElement('button');
    btn.className = 'card-btn';
    btn.innerText = `${c.emoji} ${c.name} (${c.elixir})`;
    btn.disabled = (game.player.elixir < c.elixir) || game.winner;
    btn.onclick = ()=>playCard(i);
    hand.appendChild(btn);
  });
  document.getElementById('elixir').innerText = `–ï–ª–∏–∫—Å–∏—Ä: ${Math.floor(game.player.elixir)} / ${MAX_ELIXIR}`;
}
function playCard(idx) {
  let card = CARD_TYPES[idx];
  if (game.player.elixir < card.elixir) return;
  game.player.elixir -= card.elixir;
  // –ü–æ—Å—Ç–∞–≤–∏ —é–Ω–∏—Ç –±–ª–∏–∑–æ –¥–æ –±–∞–∑–∞—Ç–∞
  let y = 320+Math.random()*40;
  let u = {
    ...card,
    x: PLAYER_BASE.x+32+Math.random()*40,
    y, maxHp: card.hp, hp: card.hp, isPlayer: true, range: 32
  };
  game.units.push(u);
  game.player.units.push(u);
}

// --- AI
function aiPlay(g) {
  if (g.winner) return;
  let available = CARD_TYPES.filter(c=>g.enemy.elixir>=c.elixir);
  if (!available.length) return;
  let card = available[Math.floor(Math.random()*available.length)];
  g.enemy.elixir -= card.elixir;
  let y = 60+Math.random()*40;
  let u = {
    ...card,
    x: ENEMY_BASE.x-32-Math.random()*40,
    y, maxHp: card.hp, hp: card.hp, isPlayer: false, range: 32
  };
  g.units.push(u);
  g.enemy.units.push(u);
}

// --- Main loop
function loop(ts) {
  let now = performance.now();
  let dt = now - (game._lastTick||now);
  game._lastTick = now;
  if (!game.winner && dt>0) {
    game.time += dt;
    gameTick(game, dt);
    aiTimer += dt;
    if (aiTimer>1500) { aiPlay(game); aiTimer=0; }
  }
  drawGame(game);
  renderHand();
  if (game.winner) {
    document.getElementById('winMsg').innerText = game.winner=='–í–ò–ï' ? '–ü–æ–±–µ–¥–∞! üéâ' : 'AI –ü–æ–±–µ–¥–∏!';
  } else document.getElementById('winMsg').innerText = '';
  requestAnimationFrame(loop);
}

// --- Init
window.onload = function() {
  ctx = document.getElementById('gameCanvas').getContext('2d');
  game = newGame();
  loop();
};
</script>
</body>
</html>
